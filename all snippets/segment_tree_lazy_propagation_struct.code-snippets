{
	"segment_Tree_lazy_assign_sum": {
		"prefix": "segment_Tree_lazy_assign_sum",
		"body": [
		  "struct item{",
		  "    ll value,lazy;",
		  "};",
		  "",
		  "struct segment_tree{",
		  "    ll size;",
		  "    vector<item>tree;",
		  "    ll neutral=0;",
		  "    ll no_op=0;",
		  "",
		  "",
		  "    //General operations : O(1)",
		  "",
		  "    ll merge(ll a,ll b){",
		  "        return (a+b);",
		  "    }",
		  "",
		  "    ll calc(ll a,ll b,ll len){",
		  "        return a+b*len;",
		  "    }",
		  "",
		  "    ll modify(ll b,ll len){",
		  "        return b*len;",
		  "    }",
		  "",
		  "    //INITIALIZATION: O(log2 n)",
		  "",
		  "    void init(ll n){",
		  "        size=1;",
		  "        while(size<n) size*=2;",
		  "        tree.resize(2*size);",
		  "    }",
		  "    ",
		  "    ///BUILD",
		  "    void build(vector<ll> &a,ll x,ll lx,ll rx){",
		  "        if(rx-lx==1){",
		  "            if(lx<a.size()){",
		  "                tree[x]={a[lx],no_op};",
		  "            }",
		  "            return;",
		  "        }",
		  "        ll m=(lx+rx)/2;",
		  "        build(a,2*x+1,lx,m);",
		  "        build(a,2*x+2,m,rx);",
		  "        tree[x]={merge(tree[2*x+1].value,tree[2*x+2].value),no_op};",
		  "    }",
		  "",
		  "    void build(vector<ll> &a){",
		  "        //linear time",
		  "        build(a,0,0,size);",
		  "    }",
		  "",
		  "    ///LAZY PROPAGATION",
		  "    ",
		  "    //throws lazy values to its children nodes ",
		  "    //updates values to children nodes",
		  "",
		  "    item propagate_op(item par,item child,ll len){",
		  "        item ret;",
		  "        ret.lazy=modify(par.lazy,1);",
		  "        ret.value=modify(par.lazy,len);",
		  "        return ret;",
		  "    }",
		  "",
		  "    void propagate(ll x,ll lx,ll rx){",
		  "        if(rx-lx==1 || tree[x].lazy==no_op){",
		  "            return;",
		  "        }",
		  "        ll m=(rx+lx)/2;",
		  "        tree[2*x+1]=propagate_op(tree[x],tree[2*x+1],m-lx);",
		  "        tree[2*x+2]=propagate_op(tree[x],tree[2*x+2],rx-m);",
		  "        tree[x].lazy=no_op;",
		  "    }",
		  "    //SET AND GET",
		  "    ",
		  "    void set(ll i,ll val,ll x,ll lx,ll rx){",
		  "        propagate(x,lx,rx);",
		  "        if(rx-lx==1){",
		  "            //leaf",
		  "            tree[x].value=val;",
		  "            tree[x].lazy=no_op;",
		  "            return;",
		  "        }",
		  "        ll m=(lx+rx)/2;",
		  "        if(i<m){",
		  "            set(i,val,2*x+1,lx,m);",
		  "        }",
		  "        else{",
		  "            set(i,val,2*x+2,m,rx);",
		  "        }",
		  "        tree[x].value=merge(tree[2*x+1].value,tree[2*x+2].value);",
		  "    }",
		  "",
		  "    void set(ll i,ll val){",
		  "        // assigns val at index i",
		  "        set(i,val,0,0,size);",
		  "    }",
		  "",
		  "     ll get(ll i,ll x,ll lx,ll rx){",
		  "        propagate(x,lx,rx);",
		  "        if(rx-lx==1) return tree[x].value;",
		  "        ll m=(lx+rx)/2;",
		  "        ll ret;",
		  "        if(i<m){",
		  "            ret=get(i,2*x+1,lx,m);",
		  "        }",
		  "        else{",
		  "            ret=get(i,2*x+2,m,rx);",
		  "        }",
		  "        tree[x].value=merge(tree[2*x+1].value,tree[2*x+2].value);",
		  "        return merge(ret,tree[x].value);",
		  "    }",
		  "    ll get(ll i){",
		  "        //gets the value of the ith position",
		  "       ",
		  "        return get(i,0,0,size);",
		  "    }",
		  "",
		  "    ///RANGE SUM",
		  "    ll sum(ll l,ll r,ll x,ll lx,ll rx){",
		  "        propagate(x,lx,rx);",
		  "        if(lx>=r || l>=rx){",
		  "            return neutral;",
		  "        }",
		  "        if(lx>=l && rx<=r){",
		  "            return tree[x].value;",
		  "        }",
		  "        ll m=(lx+rx)/2;",
		  "        ll s1=sum(l,r,2*x+1,lx,m);",
		  "        ll s2=sum(l,r,2*x+2,m,rx);",
		  "        return merge(s1,s2);",
		  "    }",
		  "    ",
		  "    ll sum(ll l,ll r){",
		  "        //returns sum from l to r",
		  "       ",
		  "        return sum(l,r,0,0,size);",
		  "    }",
		  "",
		  "    //RANGE operation",
		  "    ",
		  "    void RangeUpdate(ll l,ll r,ll v,ll x,ll lx,ll rx){",
		  "        propagate(x,lx,rx);",
		  "        if(lx>=r || l>=rx){",
		  "            return;",
		  "        }",
		  "        if(lx>=l && rx<=r){",
		  "            tree[x].lazy=merge(tree[x].lazy,v);",
		  "            tree[x].value=calc(tree[x].value,v,rx-lx);",
		  "            return;",
		  "        }",
		  "        ll m=(lx+rx)/2;",
		  "        RangeUpdate(l,r,v,2*x+1,lx,m);",
		  "        RangeUpdate(l,r,v,2*x+2,m,rx);  ",
		  "        tree[x].value=merge(tree[2*x+1].value,tree[2*x+2].value);",
		  "    }",
		  "",
		  "    void RangeUpdate(ll l,ll r,ll v){",
		  "        //multipliess v from l to r",
		  "        RangeUpdate(l,r,v,0,0,size);",
		  "    }",
		  "    ///RANGE ASSIGN",
		  "     void RangeAssign(ll l,ll r,ll v,ll x,ll lx,ll rx){",
		  "        propagate(x,lx,rx);",
		  "        if(lx>=r || l>=rx){",
		  "            return;",
		  "        }",
		  "        if(lx>=l && rx<=r){",
		  "            tree[x].lazy=modify(v,1);",
		  "            tree[x].value=modify(v,rx-lx);",
		  "            return;",
		  "        }",
		  "        ll m=(lx+rx)/2;",
		  "        RangeAssign(l,r,v,2*x+1,lx,m);",
		  "        RangeAssign(l,r,v,2*x+2,m,rx);  ",
		  "        tree[x].value=merge(tree[2*x+1].value,tree[2*x+2].value);",
		  "    }",
		  "    void RangeAssign(ll l,ll r,ll v){",
		  "        //multipliess v from l to r",
		  "      RangeAssign(l,r,v,0,0,size);",
		  "    }   ",
		  "};"
		],
		"description": "segment_Tree_lazy_assign_sum"
	  }
}