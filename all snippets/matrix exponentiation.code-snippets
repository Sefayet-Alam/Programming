{
	"matrix exponentiation": {
		"prefix": "matrix exponentiation",
		"body": [
		  "",
		  "const ll MOD = 1e9 + 7;",
		  "const ll MOD2 = MOD * MOD; /// Only when (MOD * MOD) fits into long long",
		  "#define row 3",
		  "#define col 3",
		  "// given A^n for a matrix A (or base)",
		  "struct MatExpo",
		  "{",
		  "",
		  "    ll exponents[64][row][col];",
		  "    ll base[row][col] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};     /// Base Matrix",
		  "    ll baseVect[row][col] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}; /// fibonacci sequence {1, 1, 2.....} here. So,f(1)=f(0)=1.",
		  "    ll result[row][col], mat[row][col];",
		  "",
		  "    MatExpo()",
		  "    {",
		  "        memcpy(exponents[0], base, sizeof(base));",
		  "",
		  "        /// Calculating all exponents",
		  "        for (ll p = 1; p < 62; p++)",
		  "        {",
		  "            for (ll i = 0; i < row; i++)",
		  "            {",
		  "                for (ll j = 0; j < col; j++)",
		  "                {",
		  "                    ll tmp = 0;",
		  "                    for (ll k = 0; k < col; k++)",
		  "                    {",
		  "                        tmp += exponents[p - 1][i][k] * exponents[p - 1][k][j];",
		  "                        while (tmp >= MOD2) /// Taking modulo MOD2 is easy, because we can do it by subtraction",
		  "                            tmp -= MOD2;",
		  "                    }",
		  "                    exponents[p][i][j] = tmp % MOD;",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    ll ans(ll m)",
		  "    {",
		  "",
		  "        /// Return from base case",
		  "        if (m == 1)",
		  "            return 3;",
		  "",
		  "        memcpy(mat, baseVect, sizeof(baseVect));",
		  "        ll n = m - 1, tmp; /// Here, (n - 1)th power of base matrix represents the nth term",
		  "        for (ll p = 60; p >= 0; p--)",
		  "        {",
		  "            if ((n >> p) & 1)",
		  "            {",
		  "",
		  "                for (ll i = 0; i < row; i++)",
		  "                {",
		  "",
		  "                    for (ll j = 0; j < col; j++)",
		  "                    {",
		  "                        tmp = 0;",
		  "                        for (ll k = 0; k < col; k++)",
		  "                        {",
		  "                            tmp = (tmp + exponents[p][k][j] * mat[i][k]) % MOD;",
		  "                            // while (tmp >= MOD2) /// Taking modulo MOD2 is easy, because we can do it by subtraction",
		  "                            //     tmp -= MOD2;",
		  "                        }",
		  "                        result[i][j] = tmp % MOD;",
		  "                    }",
		  "                }",
		  "",
		  "                memcpy(mat, result, sizeof(result));",
		  "            }",
		  "        }",
		  "",
		  "        ll tot = 0;",
		  "        for (ll i = 0; i < row; i++)",
		  "        {",
		  "            for (ll j = 0; j < col; j++)",
		  "            {",
		  "                tot = (tot + result[i][j]) % MOD;",
		  "            }",
		  "        }",
		  "        return tot;",
		  "    }",
		  "};",
		  ""
		],
		"description": "matrix exponentiation"
	  }
}