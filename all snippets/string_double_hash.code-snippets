{
	"string_double_Hash": {
		"prefix": "string_double_Hash",
		"body": [
		  "const ll base=33LL;",
		  "const ll M2=1e9+9;",
		  "ll pw[N];",
		  "ll inv[N];",
		  "// ll Hash[N];",
		  "vector<pair<ll,ll>>Hash(N);",
		  "ll add(ll a,ll b,ll mod){",
		  "    ll res=(a+b)%mod;",
		  "    if(res<0){",
		  "        res+=mod;",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "ll mult(ll a,ll b,ll mod){",
		  "    ll res=(a*b)%M;",
		  "    if(res<mod){",
		  "        res+=mod;",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "ll power(ll a,ll b,ll mod)",
		  "{   ll res = 1;   ",
		  "    // a=a%mod; ",
		  "    // if (a==0) return 0; ",
		  "    while(b)",
		  "    {",
		  "        if(b&1) res=mult(res,a,mod);",
		  "        b /=2;",
		  "        a=mult(a,a,mod);",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "",
		  "void precalc(){",
		  "    pw[0]=1;",
		  "    for(ll i=1;i<N;i++){",
		  "        pw[i]=mult(pw[i-1],base,M);",
		  "    }",
		  "   ll pow_inv=power(base,M-2,M);",
		  "   inv[0]=1;",
		  "     for(ll i=1;i<N;i++){",
		  "        inv[i]=mult(inv[i-1],pow_inv,M);",
		  "    }",
		  "",
		  "}",
		  "",
		  "void build(string s){",
		  "    ll n=s.size();",
		  "    for(ll i=0;i<n;i++){",
		  "        Hash[i].first=add((i==0)? 0:Hash[i-1].first,mult(pw[i],s[i]-'a'+1,M),M); ",
		  "        Hash[i].second=add((i==0)? 0:Hash[i-1].second,mult(pw[i],s[i]-'a'+1,M2),M2); ",
		  "    }",
		  "",
		  "}",
		  "",
		  "pair<ll,ll> getHash(ll x,ll y){",
		  "    ll res1=add(Hash[y].first,(x==0) ? 0: -Hash[x-1].first,M);",
		  "    res1=mult(res1, (x==0) ? 1:inv[x-1],M);",
		  "",
		  "    ll res2=add(Hash[y].second,(x==0) ? 0: -Hash[x-1].second,M2);",
		  "    res1=mult(res1, (x==0) ? 1:inv[x-1],M2);",
		  "    return {res1,res2};",
		  "}"
		],
		"description": "string_double_Hash"
	  }
}