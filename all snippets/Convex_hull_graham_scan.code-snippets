{
	"convex_hull_graham_scan": {
		"prefix": "convex_hull_graham_scan",
		"body": [
		  "vector<pll> points;",
		  "vector<pll>final_points;",
		  "ll n, x, y;",
		  "pll p0;",
		  "",
		  "pll nextToTop(stack<pll> &S)",
		  "{",
		  "    pll p = S.top();",
		  "    S.pop();",
		  "    pll res = S.top();",
		  "    S.push(p);",
		  "    return res;",
		  "}",
		  "",
		  "ll getDist(pll a,pll b){",
		  "    return (a.first - b.first)*(a.first - b.first) +",
		  "          (a.second - b.second)*(a.second - b.second);",
		  "}",
		  "int angle(pll p, pll q, pll r)",
		  "{",
		  "   ",
		  "    int val = (q.second - p.second) * (r.first - q.first) - (q.first - p.first) * (r.second - q.second);",
		  "",
		  "    if (val == 0)",
		  "        return 0;             // collinear",
		  "    return (val > 0) ? 1 : 2; // clock or counterclock wise",
		  "}",
		  "",
		  "bool cmp2(pll a, pll b)",
		  "{   ",
		  "    // if(getDist(a,p0)!=getDist(b,p0)) getDist(a,p0)<getDist(b,p0);",
		  "    if((a.second - p0.second) * (b.first - p0.first)==(b.second - p0.second) * (a.first - p0.first)) return getDist(a,p0)<getDist(b,p0);",
		  "    return (a.second - p0.second) * (b.first - p0.first) < (b.second - p0.second) * (a.first - p0.first);",
		  "}",
		  "",
		  "",
		  "void print(vector<pll> &vec,char c){",
		  "    vector<ll>xs,ys;",
		  "    for(auto it:vec){",
		  "        xs.push_back(it.first);",
		  "        ys.push_back(it.second);",
		  "    }",
		  "    cout << \"x=[\";",
		  "",
		  "    for (ll i = 0; i < xs.size(); i++)",
		  "    {",
		  "        cout << xs[i];",
		  "         if(i!=xs.size()-1) cout<< \",\";",
		  "    }",
		  "    cout <<  \"]\" << nn;",
		  "",
		  "    cout<<nn<<nn<<nn;",
		  "    cout << \"y=[\";",
		  "",
		  "    for (ll i = 0; i < xs.size(); i++)",
		  "    {",
		  "        cout << ys[i];",
		  "        if(i!=ys.size()-1) cout << \",\";",
		  "    }",
		  "    cout << \"]\" << nn;",
		  "    cout<<nn<<nn<<nn;",
		  "",
		  "    cout<<\" plt.scatter(x,y,c='\"<<c<<\"') \"<<nn;",
		  "}",
		  "void convex_hull_graham()",
		  "{",
		  "    cin >> n;",
		  "    for (ll i = 0; i < n; i++)",
		  "    {",
		  "        cin >> x >> y;",
		  "        points.push_back({x, y});",
		  "    }",
		  "    print(points,'b');",
		  "    ll ymin = points[0].second, min = 0;",
		  "    for (ll i = 1; i < n; i++)",
		  "    {",
		  "        if (ymin > points[i].second || (ymin == points[i].second && (points[min].first < points[i].first)))",
		  "        {",
		  "            ymin = points[i].second;",
		  "            min = i;",
		  "        }",
		  "    }",
		  "    swap(points[0], points[min]);",
		  "    p0=points[0];",
		  "    sort(points.begin()+1,points.end(),cmp2); // sort by p0 according to angles",
		  "    ",
		  "    for(ll i=1;i<n;i++){",
		  "         while (i < n-1 && angle(p0, points[i], points[i+1]) == 0) i++;",
		  "         final_points.push_back(points[i]);",
		  "    }",
		  "    // final_points.resize(n);",
		  "    // final_points=points;",
		  "    ll m=final_points.size();",
		  "    if(m<3){",
		  "        cout << \"No convex hull found\" << nn;",
		  "        return;",
		  "    }",
		  "    stack<pll> S;",
		  "    S.push(final_points[0]);",
		  "    S.push(final_points[1]);",
		  "    S.push(final_points[2]);",
		  " ",
		  "   for (ll i = 3; i < m; i++)",
		  "   {",
		  "      while (S.size()>1 && angle(nextToTop(S), S.top(), final_points[i]) != 2) S.pop();",
		  "      S.push(final_points[i]);",
		  "   }",
		  "   vector<pll>ans;",
		  "   while (!S.empty())",
		  "   {",
		  "       pll p = S.top();",
		  "       ans.push_back(p);",
		  "       S.pop();",
		  "   }",
		  "   ans.push_back(ans[0]);",
		  "   print(ans,'r');",
		  "   cout<<\"plt.plot(x,y,c='g')\"<<nn;",
		  "    ",
		  "}"
		],
		"description": "convex_hull_graham_scan"
	  }
}