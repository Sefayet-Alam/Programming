{
	"segment_tree_NodesHaveItems": {
		"prefix": "segment_tree_NodesHaveItems",
		"body": [
		  "",
		  "///calc calculates maximum subsegment sum from l to r",
		  "struct item{",
		  "    ll seg,pref,suff,sum;",
		  "};",
		  "struct segment_tree{",
		  "    ll size;",
		  "    vector<item>tree;",
		  "    void init(ll n){",
		  "        size=1;",
		  "        while(size<n) size*=2;",
		  "        tree.resize(2*size);",
		  "    }",
		  "    item neutral_ele={0LL,0LL,0LL,0LL};",
		  "    item merge(item a,item b){",
		  "        return {max({a.seg,b.seg,a.suff+b.pref}),max(a.pref,a.sum+b.pref),max(b.suff,b.sum+a.suff),(a.sum+b.sum)};",
		  "    }",
		  "",
		  "    item single(ll val){",
		  "        if(val>0){",
		  "            return {val,val,val,val};",
		  "        }",
		  "        return {0LL,0LL,0LL,val};",
		  "    }",
		  "    void build(vector<ll> &a,ll x,ll lx,ll rx){",
		  "        //linear time",
		  "        if(rx-lx==1){",
		  "            if(lx<a.size()){",
		  "                tree[x]=single(a[lx]);",
		  "            }",
		  "            return;",
		  "        }",
		  "        ll m=(lx+rx)/2;",
		  "        build(a,2*x+1,lx,m);",
		  "        build(a,2*x+2,m,rx);",
		  "        tree[x]=merge(tree[2*x+1],tree[2*x+2]);",
		  "    }",
		  "    void build(vector<ll> &a){",
		  "        //linear time",
		  "        build(a,0LL,0LL,size);",
		  "    }",
		  "    void set(ll i,ll val,ll x,ll lx,ll rx){",
		  "        if(rx-lx==1){",
		  "            //leaf",
		  "            tree[x]=single(val);",
		  "            return;",
		  "        }",
		  "        ll m=(lx+rx)/2;",
		  "        if(i<m){",
		  "            set(i,val,2*x+1,lx,m);",
		  "        }",
		  "        else{",
		  "            set(i,val,2*x+2,m,rx);",
		  "        }",
		  "        tree[x]=merge(tree[2*x+1],tree[2*x+2]);",
		  "    }",
		  "    void set(ll i,ll val){",
		  "        // assigns val at index i",
		  "        set(i,val,0LL,0LL,size);",
		  "    }",
		  "    item calc(ll l,ll r,ll x,ll lx,ll rx){",
		  "        if(lx>=r || l>=rx){",
		  "            return neutral_ele;",
		  "        }",
		  "        if(lx>=l && rx<=r){",
		  "            return tree[x];",
		  "        }",
		  "        ll m=(lx+rx)/2;",
		  "        item s1=calc(l,r,2*x+1,lx,m);",
		  "        item s2=calc(l,r,2*x+2,m,rx);",
		  "        return merge(s1,s2);",
		  "    }",
		  "    item calc(ll l,ll r){",
		  "        //returns sum from l to r",
		  "        return calc(l,r,0LL,0LL,size);",
		  "    }",
		  "};"
		],
		"description": "segment_tree_NodesHaveItems"
	  }
}