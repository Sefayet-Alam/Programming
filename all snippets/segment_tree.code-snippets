{
	"segment_tree": {
		"prefix": "segment_tree",
		"body": [
		  "const double EPS = 1e-9;",
		  "const int N = 2e5+10;",
		  "ll T=0;",
		  " ",
		  "ll tre[3*N];",
		  "ll lazy[3*N];",
		  " ",
		  "ll merge(ll x,ll y){",
		  "    return x+y;",
		  "}",
		  " ",
		  "void buildSegTree(vector<ll>& arr, ll treeIndex, ll lo, ll hi){",
		  " ",
		  "    if (lo == hi) {                 // leaf node. store value in node.",
		  "        tre[treeIndex] = arr[lo];",
		  "        return;",
		  "    }",
		  " ",
		  "    ll mid = lo + (hi - lo) / 2;   // recurse deeper for children.",
		  "    buildSegTree(arr, 2 * treeIndex + 1, lo, mid);",
		  "    buildSegTree(arr, 2 * treeIndex + 2, mid + 1, hi);",
		  " ",
		  "    // merge build results",
		  "    tre[treeIndex] = merge(tre[2 * treeIndex + 1], tre[2 * treeIndex + 2]);",
		  "}",
		  " ",
		  "// call this method as buildSegTree(arr, 0, 0, n-1);",
		  "// Here arr[] is input array and n is its size.",
		  " ",
		  "ll querySegTree(ll treeIndex, ll lo, ll hi, ll i, ll j){",
		  "    // query for arr[i..j]",
		  " ",
		  "    if (lo > j || hi < i)               // segment completely outside range",
		  "        return 0;                       // represents a null node",
		  " ",
		  "    if (i <= lo && j >= hi)             // segment completely inside range",
		  "        return tre[treeIndex];",
		  " ",
		  "    ll mid = lo + (hi - lo) / 2;       // partial overlap of current segment and queried range. Recurse deeper.",
		  " ",
		  "    if (i > mid)",
		  "        return querySegTree(2 * treeIndex + 2, mid + 1, hi, i, j);",
		  "    else if (j <= mid)",
		  "        return querySegTree(2 * treeIndex + 1, lo, mid, i, j);",
		  " ",
		  "    ll leftQuery = querySegTree(2 * treeIndex + 1, lo, mid, i, mid);",
		  "    ll rightQuery = querySegTree(2 * treeIndex + 2, mid + 1, hi, mid + 1, j);",
		  " ",
		  "    // merge query results",
		  "    return merge(leftQuery, rightQuery);",
		  "}",
		  " ",
		  "// call this method as querySegTree(0, 0, n-1, i, j);",
		  "// Here [i,j] is the range/interval you are querying.",
		  "// This method relies on \"null\" nodes being equivalent to storing zero.",
		  " ",
		  "void updateValSegTree(ll treeIndex, ll lo, ll hi, ll arrIndex, ll val)",
		  "{",
		  "    if (lo == hi) {                 // leaf node. update element.",
		  "        tre[treeIndex] = val;",
		  "        return;",
		  "    }",
		  " ",
		  "    ll mid = lo + (hi - lo) / 2;   // recurse deeper for appropriate child",
		  " ",
		  "    if (arrIndex > mid)",
		  "        updateValSegTree(2 * treeIndex + 2, mid + 1, hi, arrIndex, val);",
		  "    else if (arrIndex <= mid)",
		  "        updateValSegTree(2 * treeIndex + 1, lo, mid, arrIndex, val);",
		  " ",
		  "    // merge updates",
		  "    tre[treeIndex] = merge(tre[2 * treeIndex + 1], tre[2 * treeIndex + 2]);",
		  "}",
		  " ",
		  "// call this method as updateValSegTree(0, 0, n-1, i, val);",
		  "// Here you want to update the value at index i with value val.",
		  " ",
		  "void updateLazySegTree(ll treeIndex, ll lo, ll hi, ll i, ll j, ll val){",
		  "    if (lazy[treeIndex] != 0) {                             // this node is lazy",
		  "        tre[treeIndex] += (hi - lo + 1) * lazy[treeIndex]; // normalize current node by removing laziness",
		  " ",
		  "        if (lo != hi) {                                     // update lazy[] for children nodes",
		  "            lazy[2 * treeIndex + 1] += lazy[treeIndex];",
		  "            lazy[2 * treeIndex + 2] += lazy[treeIndex];",
		  "        }",
		  " ",
		  "        lazy[treeIndex] = 0;                                // current node processed. No longer lazy",
		  "    }",
		  " ",
		  "    if (lo > hi || lo > j || hi < i)",
		  "        return;                                             // out of range. escape.",
		  " ",
		  "    if (i <= lo && hi <= j) {                               // segment is fully within update range",
		  "        tre[treeIndex] += (hi - lo + 1) * val;             // update segment",
		  " ",
		  "        if (lo != hi) {                                     // update lazy[] for children",
		  "            lazy[2 * treeIndex + 1] += val;",
		  "            lazy[2 * treeIndex + 2] += val;",
		  "        }",
		  " ",
		  "        return;",
		  "    }",
		  " ",
		  "    ll mid = lo + (hi - lo) / 2;                             // recurse deeper for appropriate child",
		  " ",
		  "    updateLazySegTree(2 * treeIndex + 1, lo, mid, i, j, val);",
		  "    updateLazySegTree(2 * treeIndex + 2, mid + 1, hi, i, j, val);",
		  " ",
		  "    // merge updates",
		  "    tre[treeIndex] = tre[2 * treeIndex + 1] + tre[2 * treeIndex + 2];",
		  "}",
		  "// call this method as updateLazySegTree(0, 0, n-1, i, j, val);",
		  "// Here you want to update the range [i, j] with value val.",
		  " ",
		  "ll queryLazySegTree(ll treeIndex, ll lo, ll hi, ll i, ll j){",
		  "    // query for arr[i..j]",
		  " ",
		  "    if (lo > j || hi < i)                                   // segment completely outside range",
		  "        return 0;                                           // represents a null node",
		  " ",
		  "    if (lazy[treeIndex] != 0) {                             // this node is lazy",
		  "        tre[treeIndex] += (hi - lo + 1) * lazy[treeIndex]; // normalize current node by removing laziness",
		  " ",
		  "        if (lo != hi) {                                     // update lazy[] for children nodes",
		  "            lazy[2 * treeIndex + 1] += lazy[treeIndex];",
		  "            lazy[2 * treeIndex + 2] += lazy[treeIndex];",
		  "        }",
		  " ",
		  "        lazy[treeIndex] = 0;                                // current node processed. No longer lazy",
		  "    }",
		  " ",
		  "    if (i <= lo && j >= hi)                                 // segment completely inside range",
		  "        return tre[treeIndex];",
		  " ",
		  "    ll mid = lo + (hi - lo) / 2;                           // partial overlap of current segment and queried range. Recurse deeper.",
		  " ",
		  "    if (i > mid)",
		  "        return queryLazySegTree(2 * treeIndex + 2, mid + 1, hi, i, j);",
		  "    else if (j <= mid)",
		  "        return queryLazySegTree(2 * treeIndex + 1, lo, mid, i, j);",
		  " ",
		  "    ll leftQuery = queryLazySegTree(2 * treeIndex + 1, lo, mid, i, mid);",
		  "    ll rightQuery = queryLazySegTree(2 * treeIndex + 2, mid + 1, hi, mid + 1, j);",
		  " ",
		  "    // merge query results",
		  "    return leftQuery + rightQuery;",
		  "}",
		  "// call this method as queryLazySegTree(0, 0, n-1, i, j);",
		  "// Here [i,j] is the range/interval you are querying.",
		  "// This method relies on \"null\" nodes being equivalent to storing zero.",
		  " ",
		  "struct custom_hash {",
		  "    static uint64_t splitmix64(uint64_t x) {",
		  "        x += 0x9e3779b97f4a7c15;",
		  "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
		  "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
		  "        return x ^ (x >> 31);",
		  "    }",
		  "    size_t operator()(uint64_t x) const {",
		  "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
		  "        return splitmix64(x + FIXED_RANDOM);",
		  "    }",
		  "};",
		  ""
		],
		"description": "segment_tree"
	  }
}