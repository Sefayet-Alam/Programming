{
	"no_of_pairs_xor_palindrome": {
		"prefix": "no_of_pairs_xor_palindrome",
		"body": [
		  "ll n;",
		  "vector<ll>arr(N);",
		  "vector<ll>pals;",
		  "",
		  "bool isPalindrome(ll n) {",
		  "    string str = to_string(n);",
		  "    ll len = str.length();",
		  "    for(int i = 0; i < len/2; i++) {",
		  "        if(str[i] != str[len-1-i])",
		  "            return false;",
		  "    }",
		  "    return true;",
		  "}",
		  " ",
		  "void generatePalindromes(ll n) {",
		  "    for(ll i = 0; i < n; i++) {",
		  "        if(isPalindrome(i)){",
		  "          pals.push_back(i);",
		  "        }",
		  "    }",
		  "}",
		  "",
		  "ll xorPairCount(ll n,ll x)",
		  "{",
		  "    ll result = 0,curr_xor; ",
		  "    unordered_map<ll,ll> m;",
		  "    for (ll i=0; i<n ; i++)",
		  "    {",
		  "        curr_xor =  x^arr[i];",
		  "        if (m.find(curr_xor) != m.end()){",
		  "            result += m[curr_xor];",
		  "        }",
		  "",
		  "        m[arr[i]]++;",
		  "    }",
		  " ",
		  "    return result;",
		  "} ",
		  "",
		  "int main()",
		  "{",
		  "    fast;",
		  "     ll t;",
		  "    //setIO();",
		  "     //ll tno=1;;",
		  "     t=1;",
		  "    cin>>t;",
		  "    ll x;",
		  "    ll h=(1LL<<15);",
		  "    generatePalindromes(h);",
		  "    // cout<<pals<<nn;",
		  "    // cout<<pals.size()<<nn;",
		  "    while(t--){",
		  "      cin>>n;",
		  "      arr.resize(n);",
		  "      ll maxm=0,curr_xor;",
		  "      for(ll i=0;i<n;i++){",
		  "        cin>>arr[i];",
		  "      }",
		  "      vector<ll>freq(h+10,0);",
		  "      ll ans=0;",
		  "      for(ll i=0;i<n;i++){",
		  "        for(auto it:pals){",
		  "            curr_xor=(it^arr[i]);",
		  "            if(freq[curr_xor]){",
		  "                ans+=freq[curr_xor];",
		  "            }",
		  "        }",
		  "        freq[arr[i]]++;",
		  "     }",
		  "     cout<<ans+n<<nn;",
		  "    //   arr.clear();",
		  "    }",
		  "",
		  "",
		  "    return 0;",
		  "}",
		  "",
		  ""
		],
		"description": "no_of_pairs_xor_palindrome"
	  }
}