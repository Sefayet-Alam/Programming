{
	"persistent_segment_tree": {
		"prefix": "Persistent_Segment_tree",
		"body": [
		  "",
		  "ll dt[N], seg[120 * N], lazy[120 * N], lef[120 * N], rig[120 * N], ver[N], nf = 1;",
		  "void build(ll st, ll en, ll nd)",
		  "{",
		  "    if (st == en)",
		  "    {",
		  "        seg[nd] = dt[st];",
		  "        return;",
		  "    }",
		  "    lef[nd] = ++nf;",
		  "    rig[nd] = ++nf;",
		  "    ll mid = (st + en) / 2;",
		  "    build(st, mid, lef[nd]);",
		  "    build(mid + 1, en, rig[nd]);",
		  "    seg[nd] = seg[lef[nd]] + seg[rig[nd]];",
		  "}",
		  "ll propogate(ll st, ll en, ll nd, ll val)",
		  "{",
		  "    ll nnd = ++nf;",
		  "    lef[nnd] = lef[nd];",
		  "    rig[nnd] = rig[nd];",
		  "    lazy[nnd] = lazy[nd];",
		  "    lazy[nnd] += val;",
		  "    seg[nnd] = seg[nd] + (en - st + 1) * val;",
		  "    return nnd;",
		  "}",
		  "",
		  "ll update(ll st, ll en, ll nd, ll l, ll r, ll val)",
		  "{",
		  "    if (lazy[nd] != 0)",
		  "    {",
		  "        ll temp = lazy[nd];",
		  "        lazy[nd] = 0;",
		  "        if (st != en)",
		  "        {",
		  "            ll mid = (st + en) / 2;",
		  "            lef[nd] = propogate(st, mid, lef[nd], temp);",
		  "            rig[nd] = propogate(mid + 1, en, rig[nd], temp);",
		  "        }",
		  "    }",
		  "    if (st > r || en < l)",
		  "    {",
		  "        return nd;",
		  "    }",
		  "    ll nnd = ++nf;",
		  "    if (st >= l && en <= r)",
		  "    {",
		  "        seg[nnd] = seg[nd] + (en - st + 1) * val;",
		  "        lazy[nnd] = val;",
		  "        lef[nnd] = lef[nd];",
		  "        rig[nnd] = rig[nd];",
		  "        return nnd;",
		  "    }",
		  "    ll mid = (st + en) / 2;",
		  "    lef[nnd] = update(st, mid, lef[nd], l, r, val);",
		  "    rig[nnd] = update(mid + 1, en, rig[nd], l, r, val);",
		  "    seg[nnd] = seg[lef[nnd]] + seg[rig[nnd]];",
		  "    return nnd;",
		  "}",
		  "ll query(ll st, ll en, ll nd, ll l, ll r)",
		  "{",
		  "    if (lazy[nd] != 0)",
		  "    {",
		  "        ll temp = lazy[nd];",
		  "        lazy[nd] = 0;",
		  "        if (st != en)",
		  "        {",
		  "            ll mid = (st + en) / 2;",
		  "            lef[nd] = propogate(st, mid, lef[nd], temp);",
		  "            rig[nd] = propogate(mid + 1, en, rig[nd], temp);",
		  "        }",
		  "    }",
		  "    if (st > r || en < l)",
		  "    {",
		  "        return 0;",
		  "    }",
		  "    if (st >= l && en <= r)",
		  "    {",
		  "        return seg[nd];",
		  "    }",
		  "    ll mid = (st + en) / 2;",
		  "    return query(st, mid, lef[nd], l, r) + query(mid + 1,",
		  "                                                 en, rig[nd], l, r);",
		  "}",
		  ""
		],
		"description": "persistent_segment_tree"
	  }
}