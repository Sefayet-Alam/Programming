{
	"": {
		"prefix": "lazy propagation",
		"body": [
		  "void updateLazySegTree(int treeIndex, int lo, int hi, int i, int j, int val){",
		  "    if (lazy[treeIndex] != 0) {                             // this node is lazy",
		  "        tre[treeIndex] += (hi - lo + 1) * lazy[treeIndex]; // normalize current node by removing laziness",
		  "",
		  "        if (lo != hi) {                                     // update lazy[] for children nodes",
		  "            lazy[2 * treeIndex + 1] += lazy[treeIndex];",
		  "            lazy[2 * treeIndex + 2] += lazy[treeIndex];",
		  "        }",
		  "",
		  "        lazy[treeIndex] = 0;                                // current node processed. No longer lazy",
		  "    }",
		  "",
		  "    if (lo > hi || lo > j || hi < i)",
		  "        return;                                             // out of range. escape.",
		  "",
		  "    if (i <= lo && hi <= j) {                               // segment is fully within update range",
		  "        tre[treeIndex] += (hi - lo + 1) * val;             // update segment",
		  "",
		  "        if (lo != hi) {                                     // update lazy[] for children",
		  "            lazy[2 * treeIndex + 1] += val;",
		  "            lazy[2 * treeIndex + 2] += val;",
		  "        }",
		  "",
		  "        return;",
		  "    }",
		  "",
		  "    int mid = lo + (hi - lo) / 2;                             // recurse deeper for appropriate child",
		  "",
		  "    updateLazySegTree(2 * treeIndex + 1, lo, mid, i, j, val);",
		  "    updateLazySegTree(2 * treeIndex + 2, mid + 1, hi, i, j, val);",
		  "",
		  "    // merge updates",
		  "    tre[treeIndex] = tre[2 * treeIndex + 1] + tre[2 * treeIndex + 2];",
		  "}",
		  "// call this method as updateLazySegTree(0, 0, n-1, i, j, val);",
		  "// Here you want to update the range [i, j] with value val.",
		  "",
		  "int queryLazySegTree(int treeIndex, int lo, int hi, int i, int j){",
		  "    // query for arr[i..j]",
		  "",
		  "    if (lo > j || hi < i)                                   // segment completely outside range",
		  "        return 0;                                           // represents a null node",
		  "",
		  "    if (lazy[treeIndex] != 0) {                             // this node is lazy",
		  "        tre[treeIndex] += (hi - lo + 1) * lazy[treeIndex]; // normalize current node by removing laziness",
		  "",
		  "        if (lo != hi) {                                     // update lazy[] for children nodes",
		  "            lazy[2 * treeIndex + 1] += lazy[treeIndex];",
		  "            lazy[2 * treeIndex + 2] += lazy[treeIndex];",
		  "        }",
		  "",
		  "        lazy[treeIndex] = 0;                                // current node processed. No longer lazy",
		  "    }",
		  "",
		  "    if (i <= lo && j >= hi)                                 // segment completely inside range",
		  "        return tre[treeIndex];",
		  "",
		  "    int mid = lo + (hi - lo) / 2;                           // partial overlap of current segment and queried range. Recurse deeper.",
		  "",
		  "    if (i > mid)",
		  "        return queryLazySegTree(2 * treeIndex + 2, mid + 1, hi, i, j);",
		  "    else if (j <= mid)",
		  "        return queryLazySegTree(2 * treeIndex + 1, lo, mid, i, j);",
		  "",
		  "    int leftQuery = queryLazySegTree(2 * treeIndex + 1, lo, mid, i, mid);",
		  "    int rightQuery = queryLazySegTree(2 * treeIndex + 2, mid + 1, hi, mid + 1, j);",
		  "",
		  "    // merge query results",
		  "    return leftQuery + rightQuery;",
		  "}",
		  "// call this method as queryLazySegTree(0, 0, n-1, i, j);",
		  "// Here [i,j] is the range/interval you are querying.",
		  "// This method relies on \"null\" nodes being equivalent to storing zero."
		],
		"description": ""
	  }
}